# RandomnessQuickCheck.py üìä

A lightweight Python utility for performing **preliminary statistical checks** on binary bitstreams. This tool is designed for a **quick assessment** to determine if a set of 0s and 1s is plausibly random before proceeding with more exhaustive and computationally intensive standard test suites like NIST SP 800-22. Orginally designed to check strings quickly from a random number generator on a Quantum Computer or generated by qiskit. Author contact : nath.jroth@ p r o t o n m a i l . com

---

## üéØ Purpose

In the realm of random number generation (especially with Quantum Random Number Generators), it's crucial to verify the quality of the output. This script acts as a **first line of defense**, offering a rapid way to detect obvious non-random patterns or biases. It helps you quickly decide if your generated data is worth a deeper, more rigorous analysis using advanced statistical test suites.

---

## ‚ú® Features

* **Frequency (Monobit) Test:** Checks for an equal proportion of 0s and 1s.

* **Runs Test:** Identifies whether the number of consecutive identical bits falls within expected statistical ranges.

* **Longest Run of Ones Test:** Verifies that the longest sequence of identical bits (0s or 1s) is not unusually long or short.

* **Binary Matrix Rank Test:** Detects linear dependencies within fixed-size matrices formed from the bitstream, indicating structural patterns.

* **Discrete Fourier Transform (Spectral) Test:** Analyzes the frequency domain of the bitstream to identify hidden periodicities or repeating patterns.

* **Clear & Concise Output:** Provides formatted results for each test, including `‚úÖ PASS` / `‚ùå FAIL` indicators and descriptive details.

* **Overall Assessment:** Gives a summarized conclusion based on the combined test results.

* **Platform Agnostic:** Designed to work with any binary string input, regardless of its generation source (e.g., Qiskit QRNG, classical PRNG, etc.).

---

## üöÄ How to Use

1.  **Save the Script:** Save the provided Python code as `RandomnessQuickCheck.py`.

2.  **Install Dependencies:** Ensure you have the necessary Python libraries installed. You can install them via pip:

    ```bash
    pip install numpy scipy
    ```

3.  **Prepare Your Data:** Obtain the binary sequence (a string of '0's and '1's) you wish to test from your random number generator.

4.  **Input Your Bits:** Open `RandomnessQuickCheck.py` in a text editor or IDE. Locate the `if __name__ == "__main__":` block at the bottom.
    Replace the placeholder `your_generated_bits` with your actual binary string:

    ```python
    # --- INPUT YOUR GENERATED BITS HERE ---
    your_generated_bits = "0110101110010101011010110101101011100101011010110101" # Replace with your actual long bit string
    ```

    * **Important:** For meaningful results, especially with the Matrix Rank and DFT tests, your sequence should be **sufficiently long** (e.g., 10,000 to 100,000+ bits).

5.  **Run the Program:** Execute the script from your terminal:

    ```bash
    python RandomnessQuickCheck.py
    ```

6.  **Interpret Results:** The program will print a detailed report for each test, along with an overall assessment.

---

## üß™ Tests Included

Each test attempts to detect specific types of non-randomness. Passing all tests indicates a higher likelihood of statistical randomness for quick assessment.

* **Frequency (Monobit) Test**

    * **Checks:** If the number of 0s and 1s in the sequence is roughly equal (close to 50%).

    * **Indicates Failure If:** Significant imbalance (e.g., 60% 0s, 40% 1s).

* **Runs Test**

    * **Checks:** The number of "runs" (consecutive sequences of identical bits, like `000` or `11`). A truly random sequence has an expected number of runs.

    * **Indicates Failure If:** Too few runs (suggesting long, unbroken blocks) or too many runs (suggesting overly alternating patterns like `010101`).

* **Longest Run of Ones Test**

    * **Checks:** The length of the longest consecutive run of 1s (or 0s) in the sequence.

    * **Indicates Failure If:** The longest run is significantly longer or shorter than statistically expected for the sequence length, implying unusual clustering or scattering.

* **Binary Matrix Rank Test**

    * **Checks:** For linear dependencies within fixed-size (e.g., $32 \times 32$) binary matrices formed from the bitstream. It assesses if the matrices are "full rank" as expected in random data.

    * **Indicates Failure If:** The distribution of matrix ranks deviates from theoretical probabilities, suggesting linear correlations among bits.

* **Discrete Fourier Transform (Spectral) Test**

    * **Checks:** For periodic features (repeating patterns) in the bit sequence by analyzing its frequency components.

    * **Indicates Failure If:** Strong, significant peaks appear in the frequency spectrum, revealing hidden periodic patterns.

---

## ‚ö†Ô∏è Important Notes & Limitations

* **Quick Check Only:** This program provides a *plausibility check*. It is **not a substitute** for comprehensive, cryptographic-grade randomness testing.

* **Heuristic Assessments:** The `PASS` / `FAIL` criteria are based on simplified statistical heuristics (e.g., fixed thresholds, standard deviations).

* **P-values vs. Heuristics:** Rigorous statistical tests (like those in the NIST suite) calculate **P-values**, which provide a more precise measure of the probability that a random sequence would yield the observed results. This program does not calculate P-values.

* **Sample Size:** The reliability of these tests significantly increases with **very large sample sizes** (hundreds of thousands to millions of bits are typically required for strong statistical conclusions).

* **NIST SP 800-22:** For applications requiring high assurance (e.g., cryptography, secure key generation), it is **strongly recommended** to use the official [NIST Statistical Test Suite (NIST SP 800-22)](https://csrc.nist.gov/pubs/sp/800/22/rev1/archive/final). This provides a more exhaustive and statistically rigorous battery of tests with standardized methodologies.

This `RandomnessQuickCheck.py` tool is designed to save you time by filtering out obviously non-random sequences, allowing you to focus your more intensive NIST testing efforts on bitstreams that show initial promise.

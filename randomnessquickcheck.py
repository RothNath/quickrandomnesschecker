import collections
import math
import numpy as np
from scipy.linalg import det
import os # For checking file existence

def load_bits_from_file(filepath):
    """
    Loads a binary sequence (string of '0's and '1's) from a specified file.
    It expects the file to contain only '0's and '1's, optionally separated by whitespace.
    All whitespace characters (spaces, newlines, tabs) are removed before processing.

    Args:
        filepath (str): The path to the input file.

    Returns:
        str: The binary sequence as a single string, or an empty string if an error occurs.
    """
    if not os.path.exists(filepath):
        print(f"Error: File not found at '{filepath}'.")
        return ""
    
    try:
        with open(filepath, 'r') as f:
            content = f.read()
        
        # Remove all whitespace characters (spaces, newlines, tabs)
        bit_sequence = "".join(content.split())

        # Basic validation: ensure content only contains '0's and '1's
        if not all(bit in ('0', '1') for bit in bit_sequence):
            print(f"Error: File '{filepath}' contains characters other than '0' or '1' after removing whitespace. Please ensure your file is a pure binary stream.")
            return ""

        return bit_sequence
    except Exception as e:
        print(f"Error reading or processing file '{filepath}': {e}")
        return ""

def frequency_test(bit_sequence):
    """
    Performs a simple frequency (Monobit) test on a bit sequence.
    This checks if the proportion of 0s and 1s is approximately equal.

    Args:
        bit_sequence (str): A string of '0's and '1's generated by a random number source.

    Returns:
        dict: A dictionary containing the counts, percentages, and an assessment.
    """
    if not bit_sequence:
        return {
            "test_name": "Frequency (Monobit) Test",
            "status": "Failed",
            "details": "No bits provided for analysis.",
            "0_count": 0, "1_count": 0, "0_percentage": 0.0, "1_percentage": 0.0
        }

    # Ensure all characters in the sequence are '0' or '1'
    if not all(bit in ('0', '1') for bit in bit_sequence):
        return {
            "test_name": "Frequency (Monobit) Test",
            "status": "Failed",
            "details": "Invalid input: Bit sequence must contain only '0's and '1's."
        }

    total_bits = len(bit_sequence)
    counts = collections.Counter(bit_sequence)
    count_0 = counts.get('0', 0)
    count_1 = counts.get('1', 0)

    percentage_0 = (count_0 / total_bits) * 100
    percentage_1 = (count_1 / total_bits) * 100

    # Basic assessment for frequency test (a more rigorous approach uses p-values and confidence intervals)
    deviation = abs(percentage_0 - 50)
    if deviation < 2:
        assessment = "PASS: Frequency looks reasonably balanced. The counts of 0s and 1s are close to 50%."
        status = "Passed"
    else:
        assessment = "FAIL: Frequency imbalance detected. The counts of 0s and 1s are not close enough to 50%. This suggests a bias in the bit generation process."
        status = "Failed"

    return {
        "test_name": "Frequency (Monobit) Test",
        "status": status,
        "details": assessment,
        "0_count": count_0,
        "1_count": count_1,
        "0_percentage": percentage_0,
        "1_percentage": percentage_1
    }

def runs_test(bit_sequence):
    """
    Performs the Runs Test on a bit sequence.
    This checks if the number of runs (consecutive identical bits) is within expected limits
    for a truly random sequence.

    Args:
        bit_sequence (str): A string of '0's and '1's generated by a random number source.

    Returns:
        dict: A dictionary containing the number of runs, expected runs, and an assessment.
    """
    if len(bit_sequence) < 2:
        return {
            "test_name": "Runs Test",
            "status": "Failed",
            "details": "Sequence too short for Runs Test (minimum 2 bits required)."
        }
    if not all(bit in ('0', '1') for bit in bit_sequence):
        return {
            "test_name": "Runs Test",
            "status": "Failed",
            "details": "Invalid input: Bit sequence must contain only '0's and '1's."
        }

    n = len(bit_sequence)
    num_runs = 1 # Start with 1 run for the first bit
    for i in range(1, n):
        if bit_sequence[i] != bit_sequence[i-1]:
            num_runs += 1

    n0 = bit_sequence.count('0')
    n1 = bit_sequence.count('1')

    if n0 == 0 or n1 == 0:
         return {
            "test_name": "Runs Test",
            "status": "Failed",
            "details": "Sequence contains only one type of bit (all 0s or all 1s), cannot perform Runs Test meaningfully."
        }

    expected_runs = (2 * n0 * n1) / n + 1
    variance_runs = (2 * n0 * n1 * (2 * n0 * n1 - n)) / (n**2 * (n - 1))
    std_dev_runs = math.sqrt(variance_runs) if variance_runs > 0 else 0

    status = "Passed"
    assessment = "PASS: Number of runs is within the expected statistical range."

    # Heuristic: Check if observed runs are within 2.5 standard deviations.
    # A more rigorous test would compute a Z-score and P-value for statistical significance.
    if not (expected_runs - 2.5 * std_dev_runs <= num_runs <= expected_runs + 2.5 * std_dev_runs):
        assessment = f"FAIL: Number of runs ({num_runs}) deviates significantly from the expected range ({expected_runs:.2f} Â± {2.5*std_dev_runs:.2f}). This suggests the presence of too many or too few patterns (e.g., over-alternating or long blocks of identical bits)."
        status = "Failed"

    return {
        "test_name": "Runs Test",
        "status": status,
        "details": assessment,
        "num_runs": num_runs,
        "expected_runs": f"{expected_runs:.2f}",
        "std_dev_runs": f"{std_dev_runs:.2f}"
    }

def longest_run_of_ones_test(bit_sequence):
    """
    Performs the Longest Run of Ones Test (checks for both 0s and 1s).
    This checks if the length of the longest run of identical bits is within expected limits
    for a truly random sequence of its length.

    Args:
        bit_sequence (str): A string of '0's and '1's generated by a random number source.

    Returns:
        dict: A dictionary containing the longest run, expected longest run, and an assessment.
    """
    if not bit_sequence:
        return {
            "test_name": "Longest Run of Ones Test",
            "status": "Failed",
            "details": "No bits provided for analysis."
        }
    if not all(bit in ('0', '1') for bit in bit_sequence):
        return {
            "test_name": "Longest Run of Ones Test",
            "status": "Failed",
            "details": "Invalid input: Bit sequence must contain only '0's and '1's."
        }

    n = len(bit_sequence)
    
    max_run_ones = 0
    current_run_ones = 0
    for bit in bit_sequence:
        if bit == '1':
            current_run_ones += 1
        else:
            max_run_ones = max(max_run_ones, current_run_ones)
            current_run_ones = 0
    max_run_ones = max(max_run_ones, current_run_ones) # Check for run ending at sequence end

    max_run_zeros = 0
    current_run_zeros = 0
    for bit in bit_sequence:
        if bit == '0':
            current_run_zeros += 1
        else:
            max_run_zeros = max(max_run_zeros, current_run_zeros)
            current_run_zeros = 0
    max_run_zeros = max(max_run_zeros, current_run_zeros) # Check for run ending at sequence end

    longest_run_overall = max(max_run_ones, max_run_zeros)

    # Simplified heuristics for expected longest run range based on sequence length.
    # More precise ranges are found in statistical standards like NIST SP 800-22.
    if n < 128:
        expected_range_min, expected_range_max = 1, math.ceil(math.log2(n) + 1)
    elif n < 6272:
        expected_range_min, expected_range_max = 3, 10
    elif n < 750000:
        expected_range_min, expected_range_max = 5, 16
    else: # n >= 750000
        expected_range_min, expected_range_max = 10, 20

    status = "Passed"
    assessment = "PASS: Longest run appears to be within the statistically expected bounds."

    if not (expected_range_min <= longest_run_overall <= expected_range_max):
        assessment = f"FAIL: Longest run ({longest_run_overall}) falls outside the expected range [{expected_range_min}, {expected_range_max}]. This may indicate hidden patterns (e.g., too many long runs) or an unusual lack of variability (too many short runs)."
        status = "Failed"

    return {
        "test_name": "Longest Run of Ones Test",
        "status": status,
        "details": assessment,
        "longest_run_found": longest_run_overall,
        "longest_run_of_ones": max_run_ones,
        "longest_run_of_zeros": max_run_zeros,
        "expected_range_for_N": f"[{expected_range_min}, {expected_range_max}]"
    }

def binary_matrix_rank_test(bit_sequence, M=32, Q=32):
    """
    Performs the Binary Matrix Rank Test.
    Checks for linear dependencies within fixed-size matrices formed from the bit stream.
    Requires numpy and scipy.linalg.

    Args:
        bit_sequence (str): A string of '0's and '1's generated by a random number source.
        M (int): Number of rows in each matrix (default 32).
        Q (int): Number of columns in each matrix (default 32).

    Returns:
        dict: Test results including status and details.
    """
    if not bit_sequence:
        return {
            "test_name": "Binary Matrix Rank Test",
            "status": "Failed",
            "details": "No bits provided for analysis."
        }
    if not all(bit in ('0', '1') for bit in bit_sequence):
        return {
            "test_name": "Binary Matrix Rank Test",
            "status": "Failed",
            "details": "Invalid input: Bit sequence must contain only '0's and '1's."
        }

    n = len(bit_sequence)
    bits_per_matrix = M * Q
    if n < bits_per_matrix:
        return {
            "test_name": "Binary Matrix Rank Test",
            "status": "Failed",
            "details": f"Sequence too short for M={M}, Q={Q} matrix (minimum {bits_per_matrix} bits required). Has {n} bits."
        }

    num_matrices = math.floor(n / bits_per_matrix)
    if num_matrices < 10: # Minimum number of matrices for statistical significance as per NIST
        return {
            "test_name": "Binary Matrix Rank Test",
            "status": "Failed",
            "details": f"Too few matrices ({num_matrices}) can be formed for statistical significance (minimum 10 recommended for this test)."
        }

    # Expected probabilities for full rank (M), rank M-1, and other ranks (NIST SP 800-22 values for M=32, Q=32)
    # These are the theoretical probabilities for random binary matrices.
    expected_rank_M_prop = 0.2888
    expected_rank_M_minus_1_prop = 0.5776
    expected_rank_less_M_minus_1_prop = 0.1336
    
    rank_M_count = 0
    rank_M_minus_1_count = 0
    rank_less_M_minus_1_count = 0

    for k in range(num_matrices):
        start_idx = k * bits_per_matrix
        end_idx = start_idx + bits_per_matrix
        matrix_bits = [int(b) for b in bit_sequence[start_idx:end_idx]]
        matrix = np.array(matrix_bits).reshape((M, Q))
        
        # Calculate rank over GF(2)
        # This implementation uses standard numpy.linalg.matrix_rank, which operates over
        # real numbers. For strictly rigorous GF(2) rank, a specialized method
        # (e.g., Gaussian elimination modulo 2) would be needed. This is a common
        # approximation in practical statistical testing.
        rank = np.linalg.matrix_rank(matrix) 

        if rank == M:
            rank_M_count += 1
        elif rank == M - 1:
            rank_M_minus_1_count += 1
        else:
            rank_less_M_minus_1_count += 1
    
    observed_rank_M_prop = rank_M_count / num_matrices
    observed_rank_M_minus_1_prop = rank_M_minus_1_count / num_matrices
    observed_rank_less_M_minus_1_prop = rank_less_M_minus_1_count / num_matrices

    status = "Passed"
    assessment = "PASS: Matrix ranks appear to be distributed as expected, suggesting no significant linear dependencies."

    # Compare observed proportions to expected with a tolerance
    tolerance = 0.05 # A common tolerance for these simplified heuristic checks
    if abs(observed_rank_M_prop - expected_rank_M_prop) > tolerance or \
       abs(observed_rank_M_minus_1_prop - expected_rank_M_minus_1_prop) > tolerance or \
       abs(observed_rank_less_M_minus_1_prop - expected_rank_less_M_minus_1_prop) > tolerance:
        assessment = "FAIL: Matrix rank distribution deviates significantly from expected. This suggests the presence of linear dependencies or structural patterns within the bit stream, indicating non-randomness."
        status = "Failed"

    return {
        "test_name": "Binary Matrix Rank Test",
        "status": status,
        "details": assessment,
        f"Matrices processed (MxQ={M}x{Q})": num_matrices,
        "Observed P(rank=M)": f"{observed_rank_M_prop:.4f} (Count: {rank_M_count})",
        "Expected P(rank=M)": f"{expected_rank_M_prop:.4f}",
        "Observed P(rank=M-1)": f"{observed_rank_M_minus_1_prop:.4f} (Count: {rank_M_minus_1_count})",
        "Expected P(rank=M-1)": f"{expected_rank_M_minus_1_prop:.4f}",
        "Observed P(rank<M-1)": f"{observed_rank_less_M_minus_1_prop:.4f} (Count: {rank_less_M_minus_1_count})",
        "Expected P(rank<M-1)": f"{expected_rank_less_M_minus_1_prop:.4f}"
    }

def discrete_fourier_transform_test(bit_sequence):
    """
    Performs the Discrete Fourier Transform (Spectral) Test.
    Detects periodic features (patterns) or hidden correlations in the bit sequence
    by analyzing its frequency components.
    Requires numpy.

    Args:
        bit_sequence (str): A string of '0's and '1's generated by a random number source.

    Returns:
        dict: Test results including status and details.
    """
    if not bit_sequence:
        return {
            "test_name": "Discrete Fourier Transform (Spectral) Test",
            "status": "Failed",
            "details": "No bits provided for analysis."
        }
    if not all(bit in ('0', '1') for bit in bit_sequence):
        return {
            "test_name": "Discrete Fourier Transform (Spectral) Test",
            "status": "Failed",
            "details": "Invalid input: Bit sequence must contain only '0's and '1's."
        }

    n = len(bit_sequence)
    if n < 1000: # Minimum sequence length recommended by NIST for this test
        return {
            "test_name": "Discrete Fourier Transform (Spectral) Test",
            "status": "Failed",
            "details": f"Sequence too short for DFT test (minimum 1000 bits required). Has {n} bits."
        }

    # Convert binary sequence to a sequence of -1 and 1.
    # This transformation helps in identifying spectral properties more clearly.
    # 0 -> -1, 1 -> 1.
    x = np.array([-1 if b == '0' else 1 for b in bit_sequence])

    # Compute the Discrete Fourier Transform (DFT)
    s = np.fft.fft(x)

    # Compute the magnitudes (absolute values) of the DFT components.
    # These magnitudes indicate the strength of different frequencies in the sequence.
    m = np.abs(s)

    # Calculate the threshold (T) for identifying significant peaks.
    # This threshold is derived from statistical theory (e.g., from NIST SP 800-22 using alpha = 0.05).
    t = math.sqrt(2 * math.log(1/0.05) * n) 

    # Count the number of magnitudes that exceed the threshold.
    # The DC component (m[0]) is excluded as it relates to the overall bias, not periodicity.
    num_peaks = np.sum(m[1:math.floor(n/2)] > t)

    # For a truly random sequence, there should be very few peaks (magnitudes)
    # that significantly exceed this threshold.
    
    status = "Passed"
    assessment = "PASS: No significant periodic patterns detected. The sequence appears to lack hidden periodicities."

    # Heuristic for assessment: If a significant number of peaks (e.g., more than 2% of the
    # non-DC frequency components) exceed the threshold, it might indicate a problem.
    # A rigorous test calculates a P-value from 'num_peaks' against a chi-squared distribution.
    if num_peaks > (n / 2 - 1) * 0.02:
        assessment = f"FAIL: Too many significant peaks ({num_peaks}) in the Discrete Fourier Transform. This strongly suggests the presence of underlying periodic patterns or correlations in the bit sequence, indicating non-randomness."
        status = "Failed"

    return {
        "test_name": "Discrete Fourier Transform (Spectral) Test",
        "status": status,
        "details": assessment,
        "Number of bits (N)": n,
        "Magnitude Threshold (T)": f"{t:.2f}",
        "Number of Peaks > T": num_peaks
    }


def print_test_results(results):
    """
    Helper function to print the results of a single randomness test in a formatted way.
    """
    print(f"\n--- {results['test_name']} ---")
    print(f"  Status: {'âœ… PASS' if results['status'] == 'Passed' else 'âŒ FAIL'}")
    print(f"  Details: {results['details']}")
    
    # Print additional specific metrics for each test
    for key, value in results.items():
        if key not in ["test_name", "status", "details"]:
            cleaned_key = key.replace('_', ' ').replace('P(', 'Probability(').capitalize()
            print(f"  {cleaned_key}: {value}")


def run_all_tests(bit_sequence, sequence_name="Provided Bit Sequence"):
    """
    Runs all defined randomness tests on a given bit sequence and prints a consolidated report.

    Args:
        bit_sequence (str): The binary sequence to test.
        sequence_name (str): A descriptive name for the sequence being tested.
    """
    if not bit_sequence:
        print(f"\nNo valid bit sequence loaded for '{sequence_name}'. Skipping tests.")
        return

    print(f"\n{'='*60}")
    print(f"ðŸ“Š Randomness Report for: {sequence_name} ðŸ“Š")
    print(f"Sequence Length: {len(bit_sequence)} bits")
    print(f"First 50 bits: {bit_sequence[:50]}{'...' if len(bit_sequence) > 50 else ''}")
    print(f"{'='*60}")

    all_test_results = []

    # Run each test and store results
    all_test_results.append(frequency_test(bit_sequence))
    all_test_results.append(runs_test(bit_sequence))
    all_test_results.append(longest_run_of_ones_test(bit_sequence))
    all_test_results.append(binary_matrix_rank_test(bit_sequence))
    all_test_results.append(discrete_fourier_transform_test(bit_sequence))

    overall_passed = True
    for result in all_test_results:
        print_test_results(result)
        if result['status'] == 'Failed':
            overall_passed = False
    
    print(f"\n{'='*60}")
    if overall_passed:
        print("ðŸŽ‰ OVERALL ASSESSMENT: The sequence PASSED all selected randomness tests. ðŸŽ‰")
        print("This increases confidence in its randomness for most applications.")
    else:
        print("ðŸ’” OVERALL ASSESSMENT: The sequence FAILED one or more randomness tests. ðŸ’”")
        print("This suggests potential non-random patterns or biases. Further investigation is recommended.")
    print(f"{'='*60}")


# --- Main execution ---
if __name__ == "__main__":
    print("--- Randomness Quick Check Utility ---")
    print("This utility performs preliminary statistical tests on a binary bitstream to assess its plausibility of randomness.")

    # --- INPUT FILE PATH HERE ---
    input_filepath = input("\nEnter the path to your input file containing the binary sequence (e.g., 'data.txt'): ")
    
    # Load bits from the specified file
    bits_from_file = load_bits_from_file(input_filepath)

    if bits_from_file:
        run_all_tests(bits_from_file, f"Sequence from '{input_filepath}'")
    else:
        print("\nCould not load a valid bit sequence from the file. Please check the file path and content.")

    print("\n\n--- Important Notes for Interpretation ---")
    print("Remember that passing these tests increases your confidence in the randomness, but no finite set of statistical tests can *prove* true randomness.")
    print("For **cryptographic-grade assurance**, it's highly recommended to use the full **NIST Statistical Test Suite (NIST SP 800-22)** or other rigorously validated tools, which implement more complex statistical models and P-value analysis.")
    print("These tests are most reliable with **very large sample sizes** (typically hundreds of thousands to millions of bits).")
